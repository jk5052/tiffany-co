<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Jayce Kim | Portfolio</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            width: 100vw;
            height: 100vh;
            overflow: hidden;
            font-family: 'Times New Roman', serif;
            cursor: none;
            background: #000;
        }

        #canvas-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        /* UI Overlay */
        .ui-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }

        .header {
            position: absolute;
            top: 8%;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            color: #fff;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.2);
        }

        .header h1 {
            font-size: 1.8rem;
            font-weight: 400;
            letter-spacing: 0.4em;
            text-transform: uppercase;
            margin-bottom: 8px;
        }

        .header .subtitle {
            font-size: 0.7rem;
            letter-spacing: 0.35em;
            text-transform: uppercase;
            opacity: 0.7;
        }

        /* Custom cursor - Tiffany Key shape */
        .cursor {
            position: fixed;
            width: 50px;
            height: 50px;
            pointer-events: none;
            transform: translate(-20%, -20%);
            z-index: 1000;
            transition: transform 0.15s ease, filter 0.2s ease;
            filter: drop-shadow(2px 3px 3px rgba(0,0,0,0.3));
        }

        .cursor svg {
            width: 100%;
            height: 100%;
        }

        .cursor.hover {
            transform: translate(-20%, -20%) scale(1.2) rotate(-15deg);
            filter: drop-shadow(3px 5px 5px rgba(0,0,0,0.4));
        }

        /* Tooltip for hovered box */
        .tooltip {
            position: fixed;
            padding: 8px 16px;
            background: rgba(0,0,0,0.8);
            color: #fff;
            font-size: 0.7rem;
            letter-spacing: 0.15em;
            text-transform: uppercase;
            border-radius: 4px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s ease;
            z-index: 100;
        }

        .tooltip.visible {
            opacity: 1;
        }

        /* Art Modal Overlay - Tiffany White Gallery Style */
        .art-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(180deg, #f5f5f5 0%, #e8e8e8 50%, #d8d8d8 100%);
            z-index: 500;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.5s ease, visibility 0.5s ease;
            overflow-y: auto;
            cursor: auto;
        }

        .art-modal.visible {
            opacity: 1;
            visibility: visible;
        }

        .art-modal-content {
            max-width: 800px;
            margin: 0 auto;
            padding: 80px 60px;
        }

        .art-modal-close {
            position: fixed;
            top: 30px;
            right: 40px;
            font-size: 1.8rem;
            color: #888;
            cursor: pointer;
            z-index: 501;
            transition: all 0.3s ease;
            width: 50px;
            height: 50px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            background: rgba(255,255,255,0.8);
            box-shadow: 0 2px 15px rgba(0,0,0,0.1);
        }

        .art-modal-close:hover {
            transform: scale(1.1);
            color: #0ABAB5;
        }

        .art-modal-title {
            text-align: center;
            color: #0ABAB5;
            font-size: 1.5rem;
            letter-spacing: 0.4em;
            margin-bottom: 80px;
            font-weight: 300;
            text-transform: uppercase;
        }

        .art-item {
            margin-bottom: 100px;
            background: #fff;
            padding: 40px;
            box-shadow: 0 10px 60px rgba(0,0,0,0.08);
        }

        .art-item img, .art-item video {
            width: 100%;
            height: auto;
            display: block;
            margin-bottom: 30px;
            box-shadow: 0 5px 30px rgba(0,0,0,0.1);
        }

        .art-item-title {
            color: #333;
            font-size: 1.1rem;
            letter-spacing: 0.25em;
            margin-bottom: 18px;
            font-weight: 400;
            text-transform: uppercase;
            border-bottom: 1px solid #0ABAB5;
            padding-bottom: 12px;
            display: inline-block;
        }

        .art-item-desc {
            color: #666;
            font-size: 0.95rem;
            line-height: 2;
            letter-spacing: 0.02em;
            font-weight: 300;
        }
    </style>
</head>
<body>
    <div id="canvas-container"></div>

    <div class="ui-overlay">
        <div class="header">
            <h1>Jayce Kim</h1>
            <p class="subtitle">Design Portfolio</p>
        </div>
    </div>

    <!-- Art Modal -->
    <div class="art-modal" id="artModal">
        <div class="art-modal-close" id="artModalClose">✕</div>
        <div class="art-modal-content">
            <h2 class="art-modal-title">ART</h2>

            <div class="art-item">
                <img src="pic/Wishes.jpg" alt="Wishes">
                <h3 class="art-item-title">Wishes</h3>
                <p class="art-item-desc">Inspired by gun-related tragedies, this piece imagines a world where firearms become harmless—combining the imagery of bullets falling to the ground with the ritual of lighting candles as a collective prayer for peace.</p>
            </div>

            <div class="art-item">
                <img src="pic/Misty.jpg" alt="Misty">
                <h3 class="art-item-title">Misty</h3>
                <p class="art-item-desc">This piece invites viewers to walk into the fog toward an elusive light, exploring how perfect communication may be impossible yet encouraging us to recognize each person as a unique world and look at one another without judgment.</p>
            </div>

            <div class="art-item">
                <img src="pic/Empower.jpg" alt="Empower">
                <h3 class="art-item-title">Empower</h3>
                <p class="art-item-desc">This piece examines how modern individuals unknowingly diminish themselves, prompting reflection on what it truly takes to reclaim one's self-esteem.</p>
            </div>
        </div>
    </div>

    <!-- Interactive Installation Modal -->
    <div class="art-modal" id="installationModal">
        <div class="art-modal-close" id="installationModalClose">✕</div>
        <div class="art-modal-content">
            <h2 class="art-modal-title">INTERACTIVE INSTALLATION</h2>

            <div class="art-item">
                <img src="pic/Tension_of_Society.jpg" alt="Tension of Society">
                <h3 class="art-item-title">Tension of Society</h3>
                <p class="art-item-desc">This installation explores emotional memory—how the brain ties experiences to emotions through the connection between the hippocampus and amygdala. Using sound as a trigger for recall, the piece plays audio from Korean social tragedies such as the Sewol ferry sinking and the Daegu subway fire. As viewers listen with limited vision, a heartbeat sensor tracks their physiological response; when their heart rate crosses a threshold, the cube illuminates LED strips, creating a cumulative visual record of collective emotional resonance.</p>
            </div>

            <div class="art-item">
                <img src="pic/Eternal_Promise.jpg" alt="Eternal Promise">
                <h3 class="art-item-title">Eternal Promise</h3>
                <p class="art-item-desc">Using sensor technology, this interactive installation dissolves video imagery into particle-like atoms as viewers approach, then returns to scenes of nature when they step away—evoking the eternal cycle of matter in the universe. The piece reflects on how our loved ones, though no longer in their original form, continue to exist as atoms woven into the air we breathe, the trees we see, and the stars above, offering comfort that the bonds we share are never truly broken and that love persists beyond physical existence.</p>
            </div>
        </div>
    </div>

    <!-- Technology Modal -->
    <div class="art-modal" id="techModal">
        <div class="art-modal-close" id="techModalClose">✕</div>
        <div class="art-modal-content">
            <h2 class="art-modal-title">TECHNOLOGY</h2>

            <div class="art-item">
                <img src="pic/I_in_You.jpg" alt="I in You">
                <h3 class="art-item-title">I in You</h3>
                <p class="art-item-desc">This piece captures the moment when observation and being observed dissolve the boundaries between self and other. It reflects on how we are constantly shaped by the people we meet and experiences we encounter—absorbing diverse perspectives, values, and behaviors over time. The work invites us to see the self not as fixed, but as a fluid composite formed within a dynamic network of relationships, loves, and shared experiences.</p>
            </div>

            <div class="art-item">
                <video src="pic/Breath_Spirit.MOV" controls playsinline style="width:100%; display:block; margin-bottom:20px;"></video>
                <h3 class="art-item-title">Breath Spirit</h3>
                <p class="art-item-desc">Breath Spirit helps you build healthy breathing habits through guided pattern training, personalized meditation reminders, and progress tracking. By analyzing your breathing data, it predicts health trends and offers tailored recommendations—helping you reflect on your progress and develop a sustainable practice uniquely suited to you.</p>
            </div>
        </div>
    </div>

    <div class="cursor" id="cursor">
        <svg viewBox="0 0 60 60" fill="none" xmlns="http://www.w3.org/2000/svg">
            <!-- Key bow (oval head) -->
            <ellipse cx="18" cy="18" rx="14" ry="14" fill="none" stroke="#C0C0C0" stroke-width="4"/>
            <ellipse cx="18" cy="18" rx="14" ry="14" fill="url(#silverGradient)"/>
            <!-- Inner hole of bow -->
            <ellipse cx="18" cy="18" rx="6" ry="6" fill="#0ABAB5"/>
            <!-- Key shaft -->
            <rect x="28" y="15" width="28" height="6" rx="1" fill="url(#silverGradient)"/>
            <!-- Key teeth -->
            <rect x="48" y="21" width="4" height="6" fill="url(#silverGradient)"/>
            <rect x="40" y="21" width="3" height="4" fill="url(#silverGradient)"/>
            <!-- Gradients -->
            <defs>
                <linearGradient id="silverGradient" x1="0%" y1="0%" x2="100%" y2="100%">
                    <stop offset="0%" style="stop-color:#E8E8E8"/>
                    <stop offset="30%" style="stop-color:#C0C0C0"/>
                    <stop offset="60%" style="stop-color:#A8A8A8"/>
                    <stop offset="100%" style="stop-color:#D0D0D0"/>
                </linearGradient>
            </defs>
        </svg>
    </div>
    <div class="tooltip" id="tooltip"></div>

    <script>
        // ============== THREE.JS SETUP ==============
        let scene, camera, renderer;
        let spotLights = [];
        let mainBoxes = [];
        let decoBoxes = [];
        let raycaster, mouse;
        let hoveredBox = null;

        const cursor = document.getElementById('cursor');
        const tooltip = document.getElementById('tooltip');
        let mouseX = 0, mouseY = 0;
        let cursorX = 0, cursorY = 0;

        // Project data for main boxes
        const projects = [
            { name: 'ART', id: 'art' },
            { name: 'Interactive Installation', id: 'interactive-installation' },
            { name: 'Technology', id: 'technology' }
        ];

        init();
        animate();

        function init() {
            // Scene - Light background for illustration style
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x81D8D0);

            // Camera - front view, see the scattered layout
            camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 100);
            camera.position.set(0, 0, 18);
            camera.lookAt(0, 0, 0);

            // Renderer - clean for toon style
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            // Raycaster for mouse interaction
            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();

            // Lighting
            createLighting();

            // Create boxes
            createMainBoxes();
            createDecoBoxes();

            // Event listeners
            window.addEventListener('resize', onWindowResize);
            window.addEventListener('mousemove', onMouseMove);
            window.addEventListener('click', onClick);
        }

        function createLighting() {
            // Strong ambient for flat illustration look
            const ambient = new THREE.AmbientLight(0xffffff, 1.0);
            scene.add(ambient);

            // Soft directional for subtle shading
            const keyLight = new THREE.DirectionalLight(0xffffff, 0.5);
            keyLight.position.set(5, 8, 10);
            scene.add(keyLight);

            // Fill light from left
            const fillLight = new THREE.DirectionalLight(0xffffff, 0.3);
            fillLight.position.set(-5, 5, 5);
            scene.add(fillLight);

            // Subtle accent lights
            const accentPositions = [
                { x: -6, y: 3, z: 4 },
                { x: 6, y: 3, z: 4 }
            ];

            accentPositions.forEach((pos, i) => {
                const light = new THREE.PointLight(0xffffff, 5, 15, 2);
                light.position.set(pos.x, pos.y, pos.z);
                scene.add(light);

                spotLights.push({
                    light: light,
                    basePos: { ...pos },
                    phase: i * Math.PI,
                    speed: 0.15
                });
            });
        }

        function createTiffanyBox(width, height, depth, hasKeyhole = false) {
            const group = new THREE.Group();

            // Tiffany Blue - illustration style
            const tiffanyColor = 0x81D8D0;
            const outlineColor = 0x444444;

            // Flat material (MeshBasicMaterial for clean flat look)
            const boxMat = new THREE.MeshBasicMaterial({ color: tiffanyColor });

            // Box body
            const boxGeo = new THREE.BoxGeometry(width, height, depth);
            const box = new THREE.Mesh(boxGeo, boxMat);
            group.add(box);

            // Black outline
            const edges = new THREE.EdgesGeometry(boxGeo);
            const lineMat = new THREE.LineBasicMaterial({ color: outlineColor });
            const outline = new THREE.LineSegments(edges, lineMat);
            group.add(outline);

            // White ribbon material
            const ribbonMat = new THREE.MeshBasicMaterial({ color: 0xffffff });

            // Ribbon - horizontal (across the box)
            const ribbonHGeo = new THREE.BoxGeometry(width + 0.05, height * 0.12, depth + 0.05);
            const ribbonH = new THREE.Mesh(ribbonHGeo, ribbonMat);
            ribbonH.position.y = 0;
            group.add(ribbonH);
            group.add(new THREE.LineSegments(new THREE.EdgesGeometry(ribbonHGeo), lineMat));

            // Ribbon - vertical (across the box)
            const ribbonVGeo = new THREE.BoxGeometry(width * 0.12, height + 0.05, depth + 0.05);
            const ribbonV = new THREE.Mesh(ribbonVGeo, ribbonMat);
            ribbonV.position.y = 0;
            group.add(ribbonV);
            group.add(new THREE.LineSegments(new THREE.EdgesGeometry(ribbonVGeo), lineMat));

            // === BOW on top (ellipsoid loops) ===
            const bowY = height / 2 + height * 0.02;

            // Left loop (squashed sphere = ellipsoid)
            const loopGeo = new THREE.SphereGeometry(width * 0.18, 16, 12);
            const leftLoop = new THREE.Mesh(loopGeo, ribbonMat);
            leftLoop.scale.set(1.2, 0.5, 0.3); // flatten it
            leftLoop.position.set(-width * 0.15, bowY + height * 0.06, 0);
            group.add(leftLoop);

            // Right loop
            const rightLoop = new THREE.Mesh(loopGeo, ribbonMat);
            rightLoop.scale.set(1.2, 0.5, 0.3);
            rightLoop.position.set(width * 0.15, bowY + height * 0.06, 0);
            group.add(rightLoop);

            // Center knot (small sphere)
            const knotGeo = new THREE.SphereGeometry(width * 0.08, 12, 8);
            const knot = new THREE.Mesh(knotGeo, ribbonMat);
            knot.scale.set(1, 0.6, 0.6);
            knot.position.set(0, bowY + height * 0.04, 0);
            group.add(knot);

            // Ribbon tails (thin boxes hanging down)
            const tailGeo = new THREE.BoxGeometry(width * 0.06, height * 0.2, depth * 0.02);
            const leftTail = new THREE.Mesh(tailGeo, ribbonMat);
            leftTail.rotation.z = 0.25;
            leftTail.position.set(-width * 0.06, bowY - height * 0.08, 0);
            group.add(leftTail);

            const rightTail = new THREE.Mesh(tailGeo, ribbonMat);
            rightTail.rotation.z = -0.25;
            rightTail.position.set(width * 0.06, bowY - height * 0.08, 0);
            group.add(rightTail);

            return group;
        }

        function createMainBoxes() {
            // 3 Main boxes - BIG, scattered layout
            const configs = [
                // Left - ART
                { size: [4.0, 2.0, 4.0], pos: [-4.5, 0.8, 3], rot: [-0.06, -0.2, 0.04], floatSpeed: 0.6, floatAmp: 0.25 },
                // Center top - Interactive Installation
                { size: [4.5, 2.25, 4.5], pos: [1.5, 1.5, 2], rot: [0.07, 0.15, 0.03], floatSpeed: 0.55, floatAmp: 0.2 },
                // Right bottom - Technology
                { size: [3.8, 1.9, 3.8], pos: [5, -1.2, 3.5], rot: [0.05, 0.25, -0.04], floatSpeed: 0.65, floatAmp: 0.22 }
            ];

            configs.forEach((cfg, i) => {
                const box = createTiffanyBox(cfg.size[0], cfg.size[1], cfg.size[2], true);
                box.position.set(cfg.pos[0], cfg.pos[1], cfg.pos[2]);
                box.rotation.set(cfg.rot[0], cfg.rot[1], cfg.rot[2]);
                box.userData = {
                    isClickable: true,
                    projectIndex: i,
                    projectName: projects[i].name,
                    projectId: projects[i].id,
                    baseY: cfg.pos[1],
                    floatSpeed: cfg.floatSpeed,
                    floatAmp: cfg.floatAmp,
                    floatPhase: Math.random() * Math.PI * 2
                };
                scene.add(box);
                mainBoxes.push(box);
            });
        }

        function createDecoBoxes() {
            // Background boxes - many layers for depth
            const decoConfigs = [
                // === LAYER 1: Very far back (z: -8 to -6) - largest, most faded ===
                { size: [2.2, 1.1, 2.2], pos: [-8, 2, -8], rot: [0.1, 0.5, 0], floatSpeed: 0.4, floatAmp: 0.15, opacity: 0.25 },
                { size: [2.0, 1.0, 2.0], pos: [7, 1.5, -7], rot: [-0.08, -0.4, 0], floatSpeed: 0.45, floatAmp: 0.18, opacity: 0.25 },
                { size: [1.8, 0.9, 1.8], pos: [0, 3, -9], rot: [0.05, 0.2, 0], floatSpeed: 0.35, floatAmp: 0.2, opacity: 0.2 },
                { size: [2.1, 1.05, 2.1], pos: [-5, -0.5, -7], rot: [0.06, 0.6, 0], floatSpeed: 0.5, floatAmp: 0.12, opacity: 0.25 },
                { size: [1.9, 0.95, 1.9], pos: [5.5, 0, -8], rot: [-0.04, -0.5, 0], floatSpeed: 0.42, floatAmp: 0.16, opacity: 0.22 },
                { size: [1.7, 0.85, 1.7], pos: [-2, 4, -8], rot: [0.08, 0.3, 0], floatSpeed: 0.38, floatAmp: 0.22, opacity: 0.2 },
                { size: [1.6, 0.8, 1.6], pos: [3, 3.5, -7.5], rot: [-0.06, -0.35, 0], floatSpeed: 0.48, floatAmp: 0.19, opacity: 0.23 },

                // === LAYER 2: Mid-far back (z: -5 to -3) ===
                { size: [1.5, 0.75, 1.5], pos: [-6.5, 1, -5], rot: [0.07, 0.55, 0.03], floatSpeed: 0.55, floatAmp: 0.2, opacity: 0.35 },
                { size: [1.4, 0.7, 1.4], pos: [6, 2.5, -4.5], rot: [-0.05, -0.45, 0.02], floatSpeed: 0.6, floatAmp: 0.22, opacity: 0.35 },
                { size: [1.3, 0.65, 1.3], pos: [0, 0.5, -5], rot: [0.04, 0.15, -0.02], floatSpeed: 0.52, floatAmp: 0.18, opacity: 0.38 },
                { size: [1.35, 0.67, 1.35], pos: [-4, 3, -4], rot: [0.06, 0.7, 0.04], floatSpeed: 0.58, floatAmp: 0.24, opacity: 0.32 },
                { size: [1.25, 0.62, 1.25], pos: [4.5, -0.3, -5.5], rot: [-0.03, -0.6, -0.03], floatSpeed: 0.62, floatAmp: 0.17, opacity: 0.36 },
                { size: [1.2, 0.6, 1.2], pos: [-7, -1, -4], rot: [0.05, 0.4, 0.02], floatSpeed: 0.65, floatAmp: 0.15, opacity: 0.33 },
                { size: [1.15, 0.57, 1.15], pos: [7.5, 0.8, -5], rot: [-0.04, -0.5, 0], floatSpeed: 0.57, floatAmp: 0.2, opacity: 0.34 },

                // === LAYER 3: Near-mid (z: -2 to 0) ===
                { size: [1.1, 0.55, 1.1], pos: [-5.5, 2, -2], rot: [0.08, 0.6, 0.04], floatSpeed: 0.7, floatAmp: 0.22, opacity: 0.45 },
                { size: [1.0, 0.5, 1.0], pos: [5, 1.8, -2.5], rot: [-0.06, -0.5, 0.03], floatSpeed: 0.72, floatAmp: 0.25, opacity: 0.45 },
                { size: [0.95, 0.47, 0.95], pos: [0.5, 3.5, -3], rot: [0.04, 0.2, -0.02], floatSpeed: 0.55, floatAmp: 0.28, opacity: 0.42 },
                { size: [1.05, 0.52, 1.05], pos: [-3.5, -0.8, -1.5], rot: [0.05, 0.45, 0.03], floatSpeed: 0.75, floatAmp: 0.18, opacity: 0.48 },
                { size: [0.9, 0.45, 0.9], pos: [3.8, 2.8, -1], rot: [-0.04, -0.4, -0.02], floatSpeed: 0.68, floatAmp: 0.2, opacity: 0.46 },

                // === LAYER 4: Edges/Sides (visible periphery) ===
                { size: [0.85, 0.42, 0.85], pos: [-7, 0, 1], rot: [0.06, 0.7, 0.05], floatSpeed: 0.8, floatAmp: 0.2, opacity: 0.5 },
                { size: [0.8, 0.4, 0.8], pos: [6.5, -0.5, 2], rot: [-0.05, -0.55, -0.03], floatSpeed: 0.85, floatAmp: 0.22, opacity: 0.5 },
                { size: [0.75, 0.37, 0.75], pos: [-6, 3.5, 0], rot: [0.07, 0.5, 0.04], floatSpeed: 0.78, floatAmp: 0.26, opacity: 0.48 },
                { size: [0.7, 0.35, 0.7], pos: [5.8, 3.2, 0.5], rot: [-0.04, -0.45, 0.02], floatSpeed: 0.82, floatAmp: 0.24, opacity: 0.52 },

                // === Small accents scattered high ===
                { size: [0.65, 0.32, 0.65], pos: [-2.5, 4.5, -4], rot: [0.1, 0.8, 0.06], floatSpeed: 0.6, floatAmp: 0.32, opacity: 0.35 },
                { size: [0.6, 0.3, 0.6], pos: [2.2, 4.2, -3.5], rot: [-0.08, -0.7, -0.04], floatSpeed: 0.65, floatAmp: 0.3, opacity: 0.38 },
                { size: [0.55, 0.27, 0.55], pos: [0, 5, -6], rot: [0.05, 0.25, 0.02], floatSpeed: 0.5, floatAmp: 0.35, opacity: 0.28 },
                { size: [0.5, 0.25, 0.5], pos: [-4, 4.8, -5], rot: [0.06, 0.6, 0.03], floatSpeed: 0.55, floatAmp: 0.33, opacity: 0.3 },
                { size: [0.5, 0.25, 0.5], pos: [4.5, 4.5, -5.5], rot: [-0.05, -0.55, -0.02], floatSpeed: 0.58, floatAmp: 0.28, opacity: 0.32 },
            ];

            decoConfigs.forEach((cfg) => {
                const box = createTiffanyBox(cfg.size[0], cfg.size[1], cfg.size[2], false);
                box.position.set(cfg.pos[0], cfg.pos[1], cfg.pos[2]);
                box.rotation.set(cfg.rot[0], cfg.rot[1], cfg.rot[2]);

                // Apply depth-based opacity
                const opacity = cfg.opacity || 0.5;
                box.traverse((child) => {
                    if (child.isMesh) {
                        child.material = child.material.clone();
                        child.material.transparent = true;
                        child.material.opacity = opacity;
                    }
                });

                box.userData = {
                    isClickable: false,
                    baseY: cfg.pos[1],
                    floatSpeed: cfg.floatSpeed,
                    floatAmp: cfg.floatAmp,
                    floatPhase: Math.random() * Math.PI * 2
                };
                scene.add(box);
                decoBoxes.push(box);
            });
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function onMouseMove(event) {
            mouseX = event.clientX;
            mouseY = event.clientY;

            // Update mouse for raycaster
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
        }

        const artModal = document.getElementById('artModal');
        const artModalClose = document.getElementById('artModalClose');
        const installationModal = document.getElementById('installationModal');
        const installationModalClose = document.getElementById('installationModalClose');
        const techModal = document.getElementById('techModal');
        const techModalClose = document.getElementById('techModalClose');

        artModalClose.addEventListener('click', () => {
            artModal.classList.remove('visible');
        });

        artModal.addEventListener('click', (e) => {
            if (e.target === artModal) {
                artModal.classList.remove('visible');
            }
        });

        installationModalClose.addEventListener('click', () => {
            installationModal.classList.remove('visible');
        });

        installationModal.addEventListener('click', (e) => {
            if (e.target === installationModal) {
                installationModal.classList.remove('visible');
            }
        });

        techModalClose.addEventListener('click', () => {
            techModal.classList.remove('visible');
        });

        techModal.addEventListener('click', (e) => {
            if (e.target === techModal) {
                techModal.classList.remove('visible');
            }
        });

        function onClick() {
            if (hoveredBox && hoveredBox.userData.isClickable) {
                const projectId = hoveredBox.userData.projectId;
                const projectName = hoveredBox.userData.projectName;
                console.log('Opening:', projectId);

                if (projectId === 'art') {
                    artModal.classList.add('visible');
                } else if (projectId === 'interactive-installation') {
                    installationModal.classList.add('visible');
                } else if (projectId === 'technology') {
                    techModal.classList.add('visible');
                }
            }
        }

        function updateCursor() {
            const dx = mouseX - cursorX;
            const dy = mouseY - cursorY;
            cursorX += dx * 0.12;
            cursorY += dy * 0.12;
            cursor.style.left = cursorX + 'px';
            cursor.style.top = cursorY + 'px';
        }

        function animate() {
            requestAnimationFrame(animate);

            const time = performance.now() / 1000;

            // Animate floating boxes - like balloons
            [...mainBoxes, ...decoBoxes].forEach((box) => {
                const { baseY, floatSpeed, floatAmp, floatPhase } = box.userData;
                if (baseY !== undefined) {
                    // Gentle floating up and down
                    box.position.y = baseY + Math.sin(time * floatSpeed + floatPhase) * floatAmp;
                    // Subtle rotation sway
                    box.rotation.z = Math.sin(time * floatSpeed * 0.5 + floatPhase) * 0.03;
                    box.rotation.x = box.rotation.x + Math.sin(time * floatSpeed * 0.3) * 0.002;
                }
            });

            // Subtle light movement
            spotLights.forEach((sl, i) => {
                sl.light.position.x = sl.basePos.x + Math.sin(time * sl.speed + sl.phase) * 1.5;
                sl.light.position.y = sl.basePos.y + Math.cos(time * sl.speed * 0.7) * 0.5;
            });

            // Raycaster for hover detection
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(mainBoxes, true);

            // Reset previous hover
            if (hoveredBox) {
                hoveredBox.scale.set(1, 1, 1);
                cursor.classList.remove('hover');
                tooltip.classList.remove('visible');
                // Reset key animation
                hoveredBox.traverse((child) => {
                    if (child.userData && child.userData.isKey) {
                        child.position.z = child.userData.baseZ;
                    }
                });
            }

            if (intersects.length > 0) {
                // Find parent group
                let obj = intersects[0].object;
                while (obj.parent && !obj.userData.isClickable) {
                    obj = obj.parent;
                }

                if (obj.userData.isClickable) {
                    hoveredBox = obj;
                    hoveredBox.scale.set(1.08, 1.08, 1.08);
                    cursor.classList.add('hover');

                    // Animate keyhole - bobbing
                    hoveredBox.traverse((child) => {
                        if (child.userData && child.userData.isKey) {
                            child.position.z = child.userData.baseZ + Math.sin(time * 4) * 0.05 + 0.1;
                        }
                    });

                    // Show tooltip
                    tooltip.textContent = hoveredBox.userData.projectName;
                    tooltip.style.left = (mouseX + 20) + 'px';
                    tooltip.style.top = (mouseY - 20) + 'px';
                    tooltip.classList.add('visible');
                }
            } else {
                hoveredBox = null;
            }

            // Update cursor
            updateCursor();

            renderer.render(scene, camera);
        }
    </script>
</body>
</html>